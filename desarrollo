# -- coding: utf-8 -- 
# se va a proceder a observar el cambio en el uso ocupado por vegetacion con diferentes sensosres (landsat 5 y landsat 8), asi como con diferentes indices (NDVI y GCI)
import os, sys

try:
    from osgeo import ogr, gdal
    from osgeo.gdalconst import *
    import numpy as np
    import arcpy
  
except ImportError:
    import ogr, gdal
    from gdalconst import *
    import numpy as np
    import arcpy

# this allows GDAL to throw Python Exceptions
gdal.UseExceptions()

#definimos el directorio
os.chdir(r'C:\landsat')

##################################################################################################################
#abrimos las bandas


VerdeLS8 = gdal.Open(r'LT05_L1TP_200034_19930719_20180217_01_T1_B3.tif')
RojoLS8 = gdal.Open(r'LT05_L1TP_200034_19930719_20180217_01_T1_B4.tif')
NIRLS8 = gdal.Open(r'LT05_L1TP_200034_19930719_20180217_01_T1_B5.tif')


VerdeLS5 = gdal.Open(r'LC08_L1TP_200034_20210716_20210721_01_T1_B2.tif')
RojoLS5 = gdal.Open(r'LC08_L1TP_200034_20210716_20210721_01_T1_B3.tif')
NIRLS5 = gdal.Open(r'LC08_L1TP_200034_20210716_20210721_01_T1_B4.tif')

#de momento no lo utilizamos
#Componemos una imagen multibanda uniendo todas las bandas
landsat8= arcpy.CompositeBands_management(["VerdeLS8, RojoLS8, NIRLS8"], "Landsat8_mb.tif") 
              
landsat5= arcpy.CompositeBands_management(["VerdeLS5","RojoLS5","NIRLS5"], "Landsat5_mb.tif")


#reproyeccion
landsat5_r= arcpy.ia.Reproject(landsat5, {"wkid" : 25830})
landsat8_r= arcpy.ia.Reproject(landsat8, {"wkid" : 25830})

# verify the new coordinate system
prj = print(arcpy.Describe(landsat5_r).spatialReference.name)

# save the output
reprojected_raster.save("C:/landsat5_r.tif")

# verify the new coordinate system
prj2 = print(arcpy.Describe(landsat8_r).spatialReference.name)

# save the output
reprojected_raster.save("C:/landsat8_r.tif")

#recortar al area de interes

#Lo vamos a recortar con un recorte que esta en shp hay que pasarlo a tif y utulizarlo para recortar las capas
arcpy.Clip_management("C:/landsat5_r.tif",'#',"C:/landsat5_recortado.tif",'C:/TP5/EJ4/corredor_henares.shp')
arcpy.Clip_management("C:/landsat8_r.tif",'#',"C:/landsat8_recortado.tif",'C:/TP5/EJ4/corredor_henares.shp')
#El primero es la capa a recortar, el segundo es el nombre que le damos y el ultimo es la capa que se utiliza para recortar el # es si se utilizara con coordenadas

#obtengo la informacion de la zona recortada
#la info de las bandas
#Ruta actual
#definimos los parametros que queremos conocer
#el índice de banda comienza en 1 en lugar de 0.
#al utilizarse las bandas verde, rojo y NIR unicamenta para calcular los indices de interes (NDVI y GCI)
#Se le da orden o valor 1 al verde, 2 al rojo y 3 al NIR en los dos satelites al hacer la composicion

#actualizamos las imagenes con las que obtenemos la informacion y calculamos los indice
landsat5_rr= gdal.Open(r'C:/landsat5_recortado.tif')
landsat8_rr= gdal.Open(r'C:/landsat8_recortado.tif')


def information():
    in_ds = gdal.Open() #añadir nombre de la composicion
    in_band = in_ds.GetRasterBand()
    in_data = in_band.ReadAsArray()
    out_band = in_ds.GetRasterBand()
    out_band.WriteArray(in_data)
    print
    
    in_ds.FlushCache() #which writes the data to disk
    for i in range(1, 4):
        in_ds.GetRasterBand(i).ComputeStatistics(False)
 
    in_ds.BuildOverviews('average', [2, 4, 8, 16, 32])
    del in_ds

information (landsat5_rr)
information (landsat8_rr)
    

#dar a elegir con que indice
consulta = input ('Escoja el índice con el que quiere trabajar. Para NDVI, teclee 1 y GCI, teclee 2):  ')

print(consulta)

#definir funcion para calcular indices NDVI y GCI
# obtener bandas y tamaños de bloques

# Allow division by zero
numpy.seterr(divide='ignore', invalid='ignore')


def calcNDVI(self, filePath, outFilePath):
    # Open the inputted dataset
    dataset = gdal.Open( filePath, gdal.GA_ReadOnly )
    # Check the dataset was successfully opened
    if dataset is None:
        print ("The dataset could not opened")
        sys.exit(-1)

    # Create the output dataset
    outDataset = self.createOutputImage(outFilePath, dataset)
    # Check the datasets was successfully created.
    if outDataset is None:
        print ('Could not create output image')
        sys.exit(-1)

    # Get hold of the RED and NIR image bands from the image
    # Note that the image bands have been hard coded
    # in this case for the Landsat sensor. RED = 2
    # and NIR = 3 this might need to be changed if
    # data from another sensor was used.
    red_band = dataset.GetRasterBand(2) # RED BAND
    nir_band = dataset.GetRasterBand(3) # NIR BAND
    # Retrieve the number of lines within the image
    numLines = red_band.YSize
    # Loop through each line in turn.
    for line in range(numLines):
        # Define variable for output line.
        outputLine = ''
        # Read in data for the current line from the
        # image band representing the red wavelength
        red_scanline = red_band.ReadRaster( 0, line, red_band.XSize, 1, \
            red_band.XSize, 1, gdal.GDT_Float32 )
        # Unpack the line of data to be read as floating point data
        red_tuple = struct.unpack('f' * red_band.XSize, red_scanline)

        # Read in data for the current line from the
        # image band representing the NIR wavelength
        nir_scanline = nir_band.ReadRaster( 0, line, nir_band.XSize, 1, \
            nir_band.XSize, 1, gdal.GDT_Float32 )
        # Unpack the line of data to be read as floating point data
        nir_tuple = struct.unpack('f' * nir_band.XSize, nir_scanline)

        # Loop through the columns within the image
        for i in range(len(red_tuple)):
            #Calculate the NDVI for the current pixel.
            ndvi_lower = (nir_tuple[i] + red_tuple[i])
            ndvi_upper = (nir_tuple[i] - red_tuple[i])
            ndvi = 0
            #Be careful of zero divide
            if ndvi_lower == 0:
                ndvi = 0
            else:
                ndvi = ndvi_upper/ndvi_lower
                # Add the current pixel to the output line
                outputLine = outputLine + struct.pack('f', ndvi)
          # Write the completed line to the output image
                outDataset.GetRasterBand(1).WriteRaster(0, line, red_band.XSize, 1, \
                                            outputLine, buf_xsize=red_band.XSize,
                                            buf_ysize=1, buf_type=gdal.GDT_Float32)
      # Delete the output line following write
    del outputLine
             
  
driver = gdal.GetDriverByName("GTiff")
dst_ds = driver.Create( "ndvi.tif", shape[1], shape[0], 1, gdal.GDT_Float32)
dst_ds.SetGeoTransform( geo )
dst_ds.SetProjection( proj ) 
dst_ds.GetRasterBand(1).WriteArray(ndvi)


# Allow division by zero
numpy.seterr(divide='ignore', invalid='ignore')

# registrar todos los drivers de GDAL
gdal.AllRegister()
nomArch = 'HYP_50M_SR_W.tif'

# abrir la imagen ráster
ds = gdal.Open(nomArch, GA_ReadOnly)
if ds is None:
  print 'No se puede abrir el archivo ' + nomArch 
  sys.exit(1)

# obtener tamaño del ráster y su número de bandas
fils = ds.RasterYSize
cols = ds.RasterXSize
bandas = ds.RasterCount
print fils, cols, bandas

# get the bands and block sizes
banda1 = ds.GetRasterBand(2)
banda3 = ds.GetRasterBand(3)
blockSizes = banda1.GetBlockSize()
xBlockSize = blockSizes[0]
yBlockSize = blockSizes[1]
print yBlockSize, xBlockSize

# crear la imagen de salida tipo ndvi
driver = ds.GetDriver()
dsSal = driver.Create('ndvi.tif', cols, fils, 1, GDT_Float32)
if dsSal is None:
  print 'No se puede crear el archivo de salida ejndvi.img'
  sys.exit(1)

bandaSal = dsSal.GetRasterBand(1)

# iterar sobre las filas
for i in range(0, fils, yBlockSize):
  if i + yBlockSize < fils:
    numFilas = yBlockSize
  else:
    numFilas = fils - i

  # iterar sobre las columnas
  for j in range(0, cols, xBlockSize):
    if j + xBlockSize < cols:
      numCols = xBlockSize
    else:
      numCols = cols - j

    # read the data in
    data1 = banda1.ReadAsArray(j, i, numCols, numFilas).astype(np.float16)
    data3 = banda3.ReadAsArray(j, i, numCols, numFilas).astype(np.float16)

    # hacer los cálculos
    mascara = np.greater(data1 + data3, 0)
    ndvi = np.choose(mascara, (-99, (data3 - data1) / (data3 + data1)))

    # escribir los datos
    bandaSal.WriteArray(ndvi, j, i)

# descargar datos a disco 
bandaSal.FlushCache()

# establecer los valores NoData
bandaSal.SetNoDataValue(-99)

# calcular estadísticas
estadisticas = bandaSal.GetStatistics(0, 1)

# georeferenciar la imagen ndvi  set the projection
dsSal.SetGeoTransform(ds.GetGeoTransform())
dsSal.SetProjection(ds.GetProjection())
ds = None
dsSal = None

#Reclasifico de modo binario
def reclass():
    driver = gdal.GetDriverByName('GTiff')
    file = gdal.Open()
    band = file.GetRasterBand(1)
    lista = band.ReadAsArray()
# reclassification
    for j in  range(file.RasterXSize):
        for i in  range(file.RasterYSize):
            if lista[i,j] =0:
                lista[i,j] = 0
            elif lista[i,j] <> 0 :
                lista[i,j] = 1

def area():
    #Para calcular el área
    daShapefile =  #path where your shape file is present 
    driver = ogr.GetDriverByName('ESRI Shapefile')
    dataSource = driver.Open(daShapefile,1) # 0 means read-only. 1 means writeable.
    new_field = ogr.FieldDefn("Area", ogr.OFTReal)
    new_field.SetWidth(32)
    new_field.SetPrecision(2) #added line to set precision
    layer.CreateField(new_field)
    for feature in layer:
        geom = feature.GetGeometryRef()
        area = geom.GetArea() 
        print area
        feature.SetField("Area", area)
        layer.SetFeature(feature)

como definir un directorio en una funcion para poder utilizar la funcion 2 veces
if consulta == 1:
    NDVI_landsat5 = calcNDVI (landsat5_rr)
    NDVI_landsat8 = calcNDVI (landsat8_rr)
    print ('Calculo NDVI realizado con ambos sensores')
    difNDVI = NDVI_landsat5 - NDVI_landsat8
    
   
    reclass(difNDVI)
    RasterToPolygon_conversion(difNDVI, poli_NDVI.shp)
    area(poli_GCI.shp):
        daShapefile = (r'C:\landsat\poli_NDVI.shp')
    
ifelse:
    GCI_landsat5 = calcGCI (landsat5_rr)
    GCI_landsat8 = calcGCI (landsat8_rr)
    print ('Calculo GCI realizado con ambos sensores')
    difGCI = GCI_landsat5 - GCI_landsat8
    
    reclass(difGCI)
    #Para poligonizar
    RasterToPolygon_conversion(difGCI, poli_GCI.shp)

